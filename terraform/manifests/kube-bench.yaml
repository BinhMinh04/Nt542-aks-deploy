apiVersion: v1
kind: Secret
metadata:
  name: slack-webhook-secret
  namespace: security
type: Opaque
stringData:
  slack-webhook-url: "https://hooks.slack.com/services/YOUR/WEBHOOK/URL"

---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: kube-bench
  namespace: security
  labels:
    app: kube-bench

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: kube-bench-role
rules:
  - apiGroups: [""]
    resources: ["nodes", "pods", "serviceaccounts", "services", "configmaps", "secrets"]
    verbs: ["get", "list", "watch"]
  
  - apiGroups: ["rbac.authorization.k8s.io"]
    resources: ["clusterroles", "clusterrolebindings", "roles", "rolebindings"]
    verbs: ["get", "list", "watch"]
  
  - apiGroups: ["networking.k8s.io"]
    resources: ["networkpolicies"]
    verbs: ["get", "list", "watch"]
  
  - apiGroups: ["policy"]
    resources: ["podsecuritypolicies"]
    verbs: ["get", "list", "watch"]

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: kube-bench-rolebinding
subjects:
  - kind: ServiceAccount
    name: kube-bench
    namespace: security
roleRef:
  kind: ClusterRole
  name: kube-bench-role
  apiGroup: rbac.authorization.k8s.io
---
apiVersion: batch/v1
kind: CronJob
metadata:
  name: kube-bench-scan
  namespace: security
spec:
  schedule: "0 */1 * * *"
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 1
  jobTemplate:
    metadata:
      labels:
        app: kube-bench
    spec:
      template:
        metadata:
          labels:
            app: kube-bench
        spec:
          hostPID: true
          nodeSelector:
            kubernetes.io/os: linux
          containers:
          - name: kube-bench
            image: docker.io/aquasec/kube-bench:latest
            command: ["kube-bench"]
            args: 
            - "run"
            - "--targets"
            - "node,policies"
            - "--json"
            - "--outputfile"
            - "/results/output.json"
            - "--alsologtostderr"
            volumeMounts:
            - name: results
              mountPath: /results
            - name: var-lib-kubelet
              mountPath: /var/lib/kubelet
              readOnly: true
            - name: etc-systemd
              mountPath: /etc/systemd
              readOnly: true
            - name: etc-default
              mountPath: /etc/default
              readOnly: true
            - name: etc-kubernetes
              mountPath: /etc/kubernetes
              readOnly: true
              
          - name: slack-alert
            image: alpine:3.18
            command: ["/bin/sh"]
            args:
            - -c
            - |
              apk add --no-cache curl jq

              # Check Secret
              if [ -f "/mnt/secrets/slack-webhook-url" ]; then
                SLACK_WEBHOOK_URL=$(cat /mnt/secrets/slack-webhook-url)
              else
                echo "Error: Slack webhook secret not found"
                exit 0
              fi

              OUTPUT_FILE="/results/output.json"

              # Wait for Report
              echo "Waiting for kube-bench report..."
              for i in $(seq 1 18); do
                if [ -f "$OUTPUT_FILE" ] && [ -s "$OUTPUT_FILE" ]; then
                  echo "Report found!"
                  break
                fi
                echo "Waiting... ($i/18)"
                sleep 10
              done

              if [ ! -f "$OUTPUT_FILE" ]; then
                echo "Timeout: Output file not found."
                exit 1
              fi

              sleep 5

              # Parse Data
              PASS=$(jq '.Totals.total_pass // 0' "$OUTPUT_FILE")
              FAIL=$(jq '.Totals.total_fail // 0' "$OUTPUT_FILE")
              WARN=$(jq '.Totals.total_warn // 0' "$OUTPUT_FILE")
              SCAN_TIME=$(date '+%Y-%m-%d %H:%M:%S UTC')

              echo "Parsed: PASS=$PASS, FAIL=$FAIL, WARN=$WARN"

              # Get items and save to files
              jq -r '[.Controls[]?.tests[]?.results[]? | select(.status=="PASS")] | .[0:15] | .[] | "‚úì [\(.test_number)] \(.test_desc[0:60])"' "$OUTPUT_FILE" > /tmp/passed.txt 2>/dev/null || true
              jq -r '[.Controls[]?.tests[]?.results[]? | select(.status=="FAIL")] | .[0:15] | .[] | "‚úó [\(.test_number)] \(.test_desc[0:60])"' "$OUTPUT_FILE" > /tmp/failed.txt 2>/dev/null || true
              jq -r '[.Controls[]?.tests[]?.results[]? | select(.status=="WARN")] | .[0:10] | .[] | "‚ö† [\(.test_number)] \(.test_desc[0:60])"' "$OUTPUT_FILE" > /tmp/warn.txt 2>/dev/null || true

              # Build blocks array step by step
              cat > /tmp/payload.json << 'JSONEOF'
              {
                "blocks": [
                  {
                    "type": "header",
                    "text": {
                      "type": "plain_text",
                      "text": "üîç CIS AKS Benchmark Report",
                      "emoji": true
                    }
                  },
                  {
                    "type": "section",
                    "fields": [
                      {"type": "mrkdwn", "text": "*Target:*\nNode & Policies"},
                      {"type": "mrkdwn", "text": "*Scan Time:*\nPLACEHOLDER_TIME"}
                    ]
                  },
                  {
                    "type": "divider"
                  },
                  {
                    "type": "section",
                    "fields": [
                      {"type": "mrkdwn", "text": "‚úÖ *Pass:* PLACEHOLDER_PASS"},
                      {"type": "mrkdwn", "text": "‚ùå *Fail:* PLACEHOLDER_FAIL"},
                      {"type": "mrkdwn", "text": "‚ö†Ô∏è *Warn:* PLACEHOLDER_WARN"}
                    ]
                  },
                  {
                    "type": "divider"
                  },
                  {
                    "type": "section",
                    "text": {
                      "type": "mrkdwn",
                      "text": "*‚úÖ Passed Checks:*\n```\nPLACEHOLDER_PASSED\n```"
                    }
                  },
                  {
                    "type": "section",
                    "text": {
                      "type": "mrkdwn",
                      "text": "*‚ùå Failed Checks:*\n```\nPLACEHOLDER_FAILED\n```"
                    }
                  },
                  {
                    "type": "section",
                    "text": {
                      "type": "mrkdwn",
                      "text": "*‚ö†Ô∏è Warnings:*\n```\nPLACEHOLDER_WARN_ITEMS\n```"
                    }
                  }
                ]
              }
              JSONEOF

              # Read content from files
              PASSED_CONTENT=$(cat /tmp/passed.txt 2>/dev/null || echo "None")
              FAILED_CONTENT=$(cat /tmp/failed.txt 2>/dev/null || echo "None")
              WARN_CONTENT=$(cat /tmp/warn.txt 2>/dev/null || echo "None")

              # If empty, set to None
              [ -z "$PASSED_CONTENT" ] && PASSED_CONTENT="None"
              [ -z "$FAILED_CONTENT" ] && FAILED_CONTENT="None"
              [ -z "$WARN_CONTENT" ] && WARN_CONTENT="None"

              # Use jq to safely replace placeholders
              jq --arg time "$SCAN_TIME" \
                 --arg pass "$PASS" \
                 --arg fail "$FAIL" \
                 --arg warn "$WARN" \
                 --arg passed "$PASSED_CONTENT" \
                 --arg failed "$FAILED_CONTENT" \
                 --arg warnings "$WARN_CONTENT" \
                 '.blocks[1].fields[1].text = ("*Scan Time:*\n" + $time) |
                  .blocks[3].fields[0].text = ("‚úÖ *Pass:* " + $pass) |
                  .blocks[3].fields[1].text = ("‚ùå *Fail:* " + $fail) |
                  .blocks[3].fields[2].text = ("‚ö†Ô∏è *Warn:* " + $warn) |
                  .blocks[5].text.text = ("*‚úÖ Passed Checks:*\n```\n" + $passed + "\n```") |
                  .blocks[6].text.text = ("*‚ùå Failed Checks:*\n```\n" + $failed + "\n```") |
                  .blocks[7].text.text = ("*‚ö†Ô∏è Warnings:*\n```\n" + $warnings + "\n```")' \
                 /tmp/payload.json > /tmp/final_payload.json

              echo "=== Final Payload ==="
              cat /tmp/final_payload.json
              echo ""

              # Send to Slack
              if [ -n "$SLACK_WEBHOOK_URL" ]; then
                echo "Sending to Slack..."
                HTTP_CODE=$(curl -s -o /tmp/response.txt -w "%{http_code}" \
                  -X POST "$SLACK_WEBHOOK_URL" \
                  -H 'Content-type: application/json' \
                  -d @/tmp/final_payload.json)

                echo "HTTP Code: $HTTP_CODE"
                cat /tmp/response.txt
                echo ""

                if [ "$HTTP_CODE" = "200" ]; then
                  echo "‚úÖ Successfully sent to Slack!"
                else
                  echo "‚ùå Failed to send"
                fi
              fi
            volumeMounts:
            - name: results
              mountPath: /results
            - name: secrets
              mountPath: /mnt/secrets
              readOnly: true

          volumes:
          - name: results
            emptyDir: {}
          - name: secrets
            secret:
              secretName: slack-webhook-secret
          - name: var-lib-kubelet
            hostPath:
              path: "/var/lib/kubelet"
          - name: etc-systemd
            hostPath:
              path: "/etc/systemd"
          - name: etc-default
            hostPath:
              path: "/etc/default"
          - name: etc-kubernetes
            hostPath:
              path: "/etc/kubernetes"
          
          restartPolicy: OnFailure
          serviceAccountName: kube-bench
